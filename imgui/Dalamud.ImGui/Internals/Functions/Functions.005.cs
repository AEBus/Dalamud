// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Dalamud.Bindings.ImGui
{
	public unsafe partial class ImGuiP
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImParseFormatSanitizeForPrinting(byte* fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				ImParseFormatSanitizeForPrintingNative(fmtIn, (byte*)pfmtOut, fmtOutSize);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImParseFormatSanitizeForPrinting(byte* fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImParseFormatSanitizeForPrintingNative(fmtIn, pStr0, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImParseFormatSanitizeForPrinting(ref byte fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					ImParseFormatSanitizeForPrintingNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImParseFormatSanitizeForPrinting(ReadOnlySpan<byte> fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					ImParseFormatSanitizeForPrintingNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImParseFormatSanitizeForPrinting(string fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmtOut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmtOut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImParseFormatSanitizeForPrintingNative(pStr0, pStr1, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImParseFormatSanitizeForPrinting(ref byte fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmtOut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImParseFormatSanitizeForPrintingNative((byte*)pfmtIn, pStr0, fmtOutSize);
				fmtOut = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImParseFormatSanitizeForPrinting(ReadOnlySpan<byte> fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmtOut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImParseFormatSanitizeForPrintingNative((byte*)pfmtIn, pStr0, fmtOutSize);
				fmtOut = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void ImParseFormatSanitizeForPrinting(string fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pfmtOut = &fmtOut)
			{
				ImParseFormatSanitizeForPrintingNative(pStr0, (byte*)pfmtOut, fmtOutSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* ImParseFormatSanitizeForScanningNative(byte* fmtIn, byte* fmtOut, ulong fmtOutSize)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, ulong, byte*>)funcTable[717])(fmtIn, fmtOut, fmtOutSize);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, nint, ulong, nint>)funcTable[717])((nint)fmtIn, (nint)fmtOut, fmtOutSize);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(byte* fmtIn, byte* fmtOut, ulong fmtOutSize)
		{
			byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, fmtOut, fmtOutSize);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, byte* fmtOut, ulong fmtOutSize)
		{
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, fmtOut, fmtOutSize));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ref byte fmtIn, byte* fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, fmtOut, fmtOutSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ref byte fmtIn, byte* fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, fmtOut, fmtOutSize));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ReadOnlySpan<byte> fmtIn, byte* fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, fmtOut, fmtOutSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ReadOnlySpan<byte> fmtIn, byte* fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, fmtOut, fmtOutSize));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(string fmtIn, byte* fmtOut, ulong fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanningNative(pStr0, fmtOut, fmtOutSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(string fmtIn, byte* fmtOut, ulong fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(pStr0, fmtOut, fmtOutSize));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(byte* fmtIn, ref byte fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, (byte*)pfmtOut, fmtOutSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, ref byte fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, (byte*)pfmtOut, fmtOutSize));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(byte* fmtIn, ref string fmtOut, ulong fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, pStr0, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, ref string fmtOut, ulong fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, pStr0, fmtOutSize));
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ref byte fmtIn, ref byte fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ref byte fmtIn, ref byte fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ReadOnlySpan<byte> fmtIn, ref byte fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ReadOnlySpan<byte> fmtIn, ref byte fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(string fmtIn, ref string fmtOut, ulong fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmtOut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmtOut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanningNative(pStr0, pStr1, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(string fmtIn, ref string fmtOut, ulong fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmtOut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmtOut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(pStr0, pStr1, fmtOutSize));
			fmtOut = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ref byte fmtIn, ref string fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmtOut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, pStr0, fmtOutSize);
				fmtOut = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ref byte fmtIn, ref string fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmtOut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, pStr0, fmtOutSize));
				fmtOut = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ReadOnlySpan<byte> fmtIn, ref string fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmtOut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, pStr0, fmtOutSize);
				fmtOut = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ReadOnlySpan<byte> fmtIn, ref string fmtOut, ulong fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmtOut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, pStr0, fmtOutSize));
				fmtOut = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(string fmtIn, ref byte fmtOut, ulong fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pfmtOut = &fmtOut)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative(pStr0, (byte*)pfmtOut, fmtOutSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(string fmtIn, ref byte fmtOut, ulong fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pfmtOut = &fmtOut)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(pStr0, (byte*)pfmtOut, fmtOutSize));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(byte* fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, fmtOut, fmtOutSize);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, fmtOut, fmtOutSize));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ref byte fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, fmtOut, fmtOutSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ref byte fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, fmtOut, fmtOutSize));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ReadOnlySpan<byte> fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, fmtOut, fmtOutSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ReadOnlySpan<byte> fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, fmtOut, fmtOutSize));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(string fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanningNative(pStr0, fmtOut, fmtOutSize);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(string fmtIn, byte* fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(pStr0, fmtOut, fmtOutSize));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(byte* fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, (byte*)pfmtOut, fmtOutSize);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtOut = &fmtOut)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, (byte*)pfmtOut, fmtOutSize));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(byte* fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanningNative(fmtIn, pStr0, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(byte* fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtOut != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(fmtIn, pStr0, fmtOutSize));
			fmtOut = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ref byte fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ref byte fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ReadOnlySpan<byte> fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ReadOnlySpan<byte> fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				fixed (byte* pfmtOut = &fmtOut)
				{
					string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, (byte*)pfmtOut, fmtOutSize));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(string fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmtOut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmtOut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			byte* ret = ImParseFormatSanitizeForScanningNative(pStr0, pStr1, fmtOutSize);
			fmtOut = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(string fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (fmtOut != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(fmtOut);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(fmtOut, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(pStr0, pStr1, fmtOutSize));
			fmtOut = Utils.DecodeStringUTF8(pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ref byte fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmtOut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, pStr0, fmtOutSize);
				fmtOut = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ref byte fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = &fmtIn)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmtOut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, pStr0, fmtOutSize));
				fmtOut = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(ReadOnlySpan<byte> fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmtOut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* ret = ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, pStr0, fmtOutSize);
				fmtOut = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(ReadOnlySpan<byte> fmtIn, ref string fmtOut, nuint fmtOutSize)
		{
			fixed (byte* pfmtIn = fmtIn)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (fmtOut != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(fmtOut);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(fmtOut, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative((byte*)pfmtIn, pStr0, fmtOutSize));
				fmtOut = Utils.DecodeStringUTF8(pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImParseFormatSanitizeForScanning(string fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pfmtOut = &fmtOut)
			{
				byte* ret = ImParseFormatSanitizeForScanningNative(pStr0, (byte*)pfmtOut, fmtOutSize);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImParseFormatSanitizeForScanningS(string fmtIn, ref byte fmtOut, nuint fmtOutSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (fmtIn != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(fmtIn);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(fmtIn, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pfmtOut = &fmtOut)
			{
				string ret = Utils.DecodeStringUTF8(ImParseFormatSanitizeForScanningNative(pStr0, (byte*)pfmtOut, fmtOutSize));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImParseFormatPrecisionNative(byte* format, int defaultValue)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, int, int>)funcTable[718])(format, defaultValue);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int, int>)funcTable[718])((nint)format, defaultValue);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImParseFormatPrecision(byte* format, int defaultValue)
		{
			int ret = ImParseFormatPrecisionNative(format, defaultValue);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImParseFormatPrecision(ref byte format, int defaultValue)
		{
			fixed (byte* pformat = &format)
			{
				int ret = ImParseFormatPrecisionNative((byte*)pformat, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImParseFormatPrecision(ReadOnlySpan<byte> format, int defaultValue)
		{
			fixed (byte* pformat = format)
			{
				int ret = ImParseFormatPrecisionNative((byte*)pformat, defaultValue);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImParseFormatPrecision(string format, int defaultValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (format != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(format);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(format, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImParseFormatPrecisionNative(pStr0, defaultValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* ImTextCharToUtf8Native(byte* outBuf, uint c)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, uint, byte*>)funcTable[719])(outBuf, c);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<nint, uint, nint>)funcTable[719])((nint)outBuf, c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImTextCharToUtf8(byte* outBuf, uint c)
		{
			byte* ret = ImTextCharToUtf8Native(outBuf, c);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImTextCharToUtf8S(byte* outBuf, uint c)
		{
			string ret = Utils.DecodeStringUTF8(ImTextCharToUtf8Native(outBuf, c));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImTextCharToUtf8(ref byte outBuf, uint c)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				byte* ret = ImTextCharToUtf8Native((byte*)poutBuf, c);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImTextCharToUtf8S(ref byte outBuf, uint c)
		{
			fixed (byte* poutBuf = &outBuf)
			{
				string ret = Utils.DecodeStringUTF8(ImTextCharToUtf8Native((byte*)poutBuf, c));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static byte* ImTextCharToUtf8(ReadOnlySpan<byte> outBuf, uint c)
		{
			fixed (byte* poutBuf = outBuf)
			{
				byte* ret = ImTextCharToUtf8Native((byte*)poutBuf, c);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static string ImTextCharToUtf8S(ReadOnlySpan<byte> outBuf, uint c)
		{
			fixed (byte* poutBuf = outBuf)
			{
				string ret = Utils.DecodeStringUTF8(ImTextCharToUtf8Native((byte*)poutBuf, c));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImTextCharFromUtf8Native(uint* outChar, byte* inText, byte* inTextEnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint*, byte*, byte*, int>)funcTable[720])(outChar, inText, inTextEnd);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, nint, int>)funcTable[720])((nint)outChar, (nint)inText, (nint)inTextEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, byte* inTextEnd)
		{
			int ret = ImTextCharFromUtf8Native(outChar, inText, inTextEnd);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				int ret = ImTextCharFromUtf8Native((uint*)poutChar, inText, inTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, inTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, ReadOnlySpan<byte> inText, byte* inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, inTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCharFromUtf8Native(outChar, pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					int ret = ImTextCharFromUtf8Native((uint*)poutChar, (byte*)pinText, inTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, ReadOnlySpan<byte> inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = inText)
				{
					int ret = ImTextCharFromUtf8Native((uint*)poutChar, (byte*)pinText, inTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, string inText, byte* inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCharFromUtf8Native((uint*)poutChar, pStr0, inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCharFromUtf8Native(outChar, inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImTextCharFromUtf8Native(outChar, inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCharFromUtf8Native(outChar, inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCharFromUtf8Native((uint*)poutChar, inText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImTextCharFromUtf8Native((uint*)poutChar, inText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, byte* inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCharFromUtf8Native((uint*)poutChar, inText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, ReadOnlySpan<byte> inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextCharFromUtf8Native(outChar, pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, ref byte inText, string inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, ReadOnlySpan<byte> inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, ReadOnlySpan<byte> inText, string inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCharFromUtf8Native(outChar, (byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, string inText, ref byte inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCharFromUtf8Native(outChar, pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(uint* outChar, string inText, ReadOnlySpan<byte> inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImTextCharFromUtf8Native(outChar, pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte* pinTextEnd = &inTextEnd)
					{
						int ret = ImTextCharFromUtf8Native((uint*)poutChar, (byte*)pinText, (byte*)pinTextEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, ReadOnlySpan<byte> inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = inText)
				{
					fixed (byte* pinTextEnd = inTextEnd)
					{
						int ret = ImTextCharFromUtf8Native((uint*)poutChar, (byte*)pinText, (byte*)pinTextEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, string inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				byte* pStr1 = null;
				int pStrSize1 = 0;
				if (inTextEnd != null)
				{
					pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize1 >= Utils.MaxStackallocSize)
					{
						pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
					}
					else
					{
						byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
						pStr1 = pStrStack1;
					}
					int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
					pStr1[pStrOffset1] = 0;
				}
				int ret = ImTextCharFromUtf8Native((uint*)poutChar, pStr0, pStr1);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr1);
				}
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					fixed (byte* pinTextEnd = inTextEnd)
					{
						int ret = ImTextCharFromUtf8Native((uint*)poutChar, (byte*)pinText, (byte*)pinTextEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, ref byte inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = &inText)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (inTextEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					int ret = ImTextCharFromUtf8Native((uint*)poutChar, (byte*)pinText, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, ReadOnlySpan<byte> inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = inText)
				{
					fixed (byte* pinTextEnd = &inTextEnd)
					{
						int ret = ImTextCharFromUtf8Native((uint*)poutChar, (byte*)pinText, (byte*)pinTextEnd);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, ReadOnlySpan<byte> inText, string inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				fixed (byte* pinText = inText)
				{
					byte* pStr0 = null;
					int pStrSize0 = 0;
					if (inTextEnd != null)
					{
						pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
						if (pStrSize0 >= Utils.MaxStackallocSize)
						{
							pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
						}
						else
						{
							byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
							pStr0 = pStrStack0;
						}
						int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
						pStr0[pStrOffset0] = 0;
					}
					int ret = ImTextCharFromUtf8Native((uint*)poutChar, (byte*)pinText, pStr0);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, string inText, ref byte inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCharFromUtf8Native((uint*)poutChar, pStr0, (byte*)pinTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCharFromUtf8(ref uint outChar, string inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (uint* poutChar = &outChar)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inText != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inText);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImTextCharFromUtf8Native((uint*)poutChar, pStr0, (byte*)pinTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						Utils.Free(pStr0);
					}
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImTextCountCharsFromUtf8Native(byte* inText, byte* inTextEnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)funcTable[721])(inText, inTextEnd);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[721])((nint)inText, (nint)inTextEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(byte* inText, byte* inTextEnd)
		{
			int ret = ImTextCountCharsFromUtf8Native(inText, inTextEnd);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextCountCharsFromUtf8Native((byte*)pinText, inTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(ReadOnlySpan<byte> inText, byte* inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				int ret = ImTextCountCharsFromUtf8Native((byte*)pinText, inTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountCharsFromUtf8Native(pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountCharsFromUtf8Native(inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(byte* inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImTextCountCharsFromUtf8Native(inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountCharsFromUtf8Native(inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCountCharsFromUtf8Native((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(ReadOnlySpan<byte> inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImTextCountCharsFromUtf8Native((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextCountCharsFromUtf8Native(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(ref byte inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImTextCountCharsFromUtf8Native((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(ref byte inText, string inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCountCharsFromUtf8Native((byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(ReadOnlySpan<byte> inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCountCharsFromUtf8Native((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(ReadOnlySpan<byte> inText, string inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCountCharsFromUtf8Native((byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(string inText, ref byte inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountCharsFromUtf8Native(pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountCharsFromUtf8(string inText, ReadOnlySpan<byte> inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImTextCountCharsFromUtf8Native(pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImTextCountUtf8BytesFromCharNative(byte* inText, byte* inTextEnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, int>)funcTable[722])(inText, inTextEnd);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[722])((nint)inText, (nint)inTextEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(byte* inText, byte* inTextEnd)
		{
			int ret = ImTextCountUtf8BytesFromCharNative(inText, inTextEnd);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(ref byte inText, byte* inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				int ret = ImTextCountUtf8BytesFromCharNative((byte*)pinText, inTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(ReadOnlySpan<byte> inText, byte* inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				int ret = ImTextCountUtf8BytesFromCharNative((byte*)pinText, inTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(string inText, byte* inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountUtf8BytesFromCharNative(pStr0, inTextEnd);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(byte* inText, ref byte inTextEnd)
		{
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountUtf8BytesFromCharNative(inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(byte* inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImTextCountUtf8BytesFromCharNative(inText, (byte*)pinTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(byte* inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inTextEnd != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = ImTextCountUtf8BytesFromCharNative(inText, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(ref byte inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCountUtf8BytesFromCharNative((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(ReadOnlySpan<byte> inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImTextCountUtf8BytesFromCharNative((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(string inText, string inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (inTextEnd != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(inTextEnd);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(inTextEnd, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			int ret = ImTextCountUtf8BytesFromCharNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(ref byte inText, ReadOnlySpan<byte> inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				fixed (byte* pinTextEnd = inTextEnd)
				{
					int ret = ImTextCountUtf8BytesFromCharNative((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(ref byte inText, string inTextEnd)
		{
			fixed (byte* pinText = &inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCountUtf8BytesFromCharNative((byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(ReadOnlySpan<byte> inText, ref byte inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				fixed (byte* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCountUtf8BytesFromCharNative((byte*)pinText, (byte*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(ReadOnlySpan<byte> inText, string inTextEnd)
		{
			fixed (byte* pinText = inText)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (inTextEnd != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(inTextEnd);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(inTextEnd, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				int ret = ImTextCountUtf8BytesFromCharNative((byte*)pinText, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(string inText, ref byte inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountUtf8BytesFromCharNative(pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromChar(string inText, ReadOnlySpan<byte> inTextEnd)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (inText != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(inText);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(inText, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pinTextEnd = inTextEnd)
			{
				int ret = ImTextCountUtf8BytesFromCharNative(pStr0, (byte*)pinTextEnd);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ImTextCountUtf8BytesFromStrNative(ushort* inText, ushort* inTextEnd)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ushort*, ushort*, int>)funcTable[723])(inText, inTextEnd);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, nint, int>)funcTable[723])((nint)inText, (nint)inTextEnd);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromStr(ushort* inText, ushort* inTextEnd)
		{
			int ret = ImTextCountUtf8BytesFromStrNative(inText, inTextEnd);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromStr(ref ushort inText, ushort* inTextEnd)
		{
			fixed (ushort* pinText = &inText)
			{
				int ret = ImTextCountUtf8BytesFromStrNative((ushort*)pinText, inTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromStr(ushort* inText, ref ushort inTextEnd)
		{
			fixed (ushort* pinTextEnd = &inTextEnd)
			{
				int ret = ImTextCountUtf8BytesFromStrNative(inText, (ushort*)pinTextEnd);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static int ImTextCountUtf8BytesFromStr(ref ushort inText, ref ushort inTextEnd)
		{
			fixed (ushort* pinText = &inText)
			{
				fixed (ushort* pinTextEnd = &inTextEnd)
				{
					int ret = ImTextCountUtf8BytesFromStrNative((ushort*)pinText, (ushort*)pinTextEnd);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ImFileHandle ImFileOpenNative(byte* filename, byte* mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, ImFileHandle>)funcTable[724])(filename, mode);
			#else
			return (ImFileHandle)((delegate* unmanaged[Cdecl]<nint, nint, ImFileHandle>)funcTable[724])((nint)filename, (nint)mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(byte* filename, byte* mode)
		{
			ImFileHandle ret = ImFileOpenNative(filename, mode);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(ref byte filename, byte* mode)
		{
			fixed (byte* pfilename = &filename)
			{
				ImFileHandle ret = ImFileOpenNative((byte*)pfilename, mode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(ReadOnlySpan<byte> filename, byte* mode)
		{
			fixed (byte* pfilename = filename)
			{
				ImFileHandle ret = ImFileOpenNative((byte*)pfilename, mode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(string filename, byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFileHandle ret = ImFileOpenNative(pStr0, mode);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(byte* filename, ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				ImFileHandle ret = ImFileOpenNative(filename, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(byte* filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				ImFileHandle ret = ImFileOpenNative(filename, (byte*)pmode);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(byte* filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ImFileHandle ret = ImFileOpenNative(filename, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(ref byte filename, ref byte mode)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					ImFileHandle ret = ImFileOpenNative((byte*)pfilename, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(ReadOnlySpan<byte> filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = mode)
				{
					ImFileHandle ret = ImFileOpenNative((byte*)pfilename, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(string filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			ImFileHandle ret = ImFileOpenNative(pStr0, pStr1);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(ref byte filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = mode)
				{
					ImFileHandle ret = ImFileOpenNative((byte*)pfilename, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(ref byte filename, string mode)
		{
			fixed (byte* pfilename = &filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFileHandle ret = ImFileOpenNative((byte*)pfilename, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(ReadOnlySpan<byte> filename, ref byte mode)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = &mode)
				{
					ImFileHandle ret = ImFileOpenNative((byte*)pfilename, (byte*)pmode);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(ReadOnlySpan<byte> filename, string mode)
		{
			fixed (byte* pfilename = filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				ImFileHandle ret = ImFileOpenNative((byte*)pfilename, pStr0);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(string filename, ref byte mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = &mode)
			{
				ImFileHandle ret = ImFileOpenNative(pStr0, (byte*)pmode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ImFileHandle ImFileOpen(string filename, ReadOnlySpan<byte> mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = mode)
			{
				ImFileHandle ret = ImFileOpenNative(pStr0, (byte*)pmode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ImFileCloseNative(ImFileHandle file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFileHandle, byte>)funcTable[725])(file);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ImFileHandle, byte>)funcTable[725])(file);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static bool ImFileClose(ImFileHandle file)
		{
			byte ret = ImFileCloseNative(file);
			return ret != 0;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ImFileGetSizeNative(ImFileHandle file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ImFileHandle, ulong>)funcTable[726])(file);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<ImFileHandle, ulong>)funcTable[726])(file);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImFileGetSize(ImFileHandle file)
		{
			ulong ret = ImFileGetSizeNative(file);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ImFileReadNative(void* data, ulong size, ulong count, ImFileHandle file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, ulong, ulong, ImFileHandle, ulong>)funcTable[727])(data, size, count, file);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong, ulong, ImFileHandle, ulong>)funcTable[727])((nint)data, size, count, file);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImFileRead(void* data, ulong size, ulong count, ImFileHandle file)
		{
			ulong ret = ImFileReadNative(data, size, count, file);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong ImFileWriteNative(void* data, ulong size, ulong count, ImFileHandle file)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, ulong, ulong, ImFileHandle, ulong>)funcTable[728])(data, size, count, file);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<nint, ulong, ulong, ImFileHandle, ulong>)funcTable[728])((nint)data, size, count, file);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static ulong ImFileWrite(void* data, ulong size, ulong count, ImFileHandle file)
		{
			ulong ret = ImFileWriteNative(data, size, count, file);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* ImFileLoadToMemoryNative(byte* filename, byte* mode, ulong* outFileSize, int paddingBytes)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, byte*, ulong*, int, void*>)funcTable[729])(filename, mode, outFileSize, paddingBytes);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, nint>)funcTable[729])((nint)filename, (nint)mode, (nint)outFileSize, paddingBytes);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, byte* mode, ulong* outFileSize, int paddingBytes)
		{
			void* ret = ImFileLoadToMemoryNative(filename, mode, outFileSize, paddingBytes);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, byte* mode, ulong* outFileSize)
		{
			void* ret = ImFileLoadToMemoryNative(filename, mode, outFileSize, (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, byte* mode)
		{
			void* ret = ImFileLoadToMemoryNative(filename, mode, (ulong*)(default), (int)(0));
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, byte* mode, int paddingBytes)
		{
			void* ret = ImFileLoadToMemoryNative(filename, mode, (ulong*)(default), paddingBytes);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, byte* mode, ulong* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, mode, outFileSize, paddingBytes);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, byte* mode, ulong* outFileSize)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, mode, outFileSize, (int)(0));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, byte* mode)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, mode, (ulong*)(default), (int)(0));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, byte* mode, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, mode, (ulong*)(default), paddingBytes);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, byte* mode, ulong* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, mode, outFileSize, paddingBytes);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, byte* mode, ulong* outFileSize)
		{
			fixed (byte* pfilename = filename)
			{
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, mode, outFileSize, (int)(0));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, byte* mode)
		{
			fixed (byte* pfilename = filename)
			{
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, mode, (ulong*)(default), (int)(0));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, byte* mode, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, mode, (ulong*)(default), paddingBytes);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, byte* mode, ulong* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(pStr0, mode, outFileSize, paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, byte* mode, ulong* outFileSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(pStr0, mode, outFileSize, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, byte* mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(pStr0, mode, (ulong*)(default), (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, byte* mode, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(pStr0, mode, (ulong*)(default), paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, ref byte mode, ulong* outFileSize, int paddingBytes)
		{
			fixed (byte* pmode = &mode)
			{
				void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, outFileSize, paddingBytes);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, ref byte mode, ulong* outFileSize)
		{
			fixed (byte* pmode = &mode)
			{
				void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, outFileSize, (int)(0));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, ref byte mode)
		{
			fixed (byte* pmode = &mode)
			{
				void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, (ulong*)(default), (int)(0));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, ref byte mode, int paddingBytes)
		{
			fixed (byte* pmode = &mode)
			{
				void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, (ulong*)(default), paddingBytes);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, ReadOnlySpan<byte> mode, ulong* outFileSize, int paddingBytes)
		{
			fixed (byte* pmode = mode)
			{
				void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, outFileSize, paddingBytes);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, ReadOnlySpan<byte> mode, ulong* outFileSize)
		{
			fixed (byte* pmode = mode)
			{
				void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, outFileSize, (int)(0));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pmode = mode)
			{
				void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, (ulong*)(default), (int)(0));
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, ReadOnlySpan<byte> mode, int paddingBytes)
		{
			fixed (byte* pmode = mode)
			{
				void* ret = ImFileLoadToMemoryNative(filename, (byte*)pmode, (ulong*)(default), paddingBytes);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, string mode, ulong* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(filename, pStr0, outFileSize, paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, string mode, ulong* outFileSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(filename, pStr0, outFileSize, (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(filename, pStr0, (ulong*)(default), (int)(0));
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(byte* filename, string mode, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mode != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mode);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(filename, pStr0, (ulong*)(default), paddingBytes);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode, ulong* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, outFileSize, paddingBytes);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode, ulong* outFileSize)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, outFileSize, (int)(0));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, (ulong*)(default), (int)(0));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, ref byte mode, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, (ulong*)(default), paddingBytes);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ReadOnlySpan<byte> mode, ulong* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, outFileSize, paddingBytes);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ReadOnlySpan<byte> mode, ulong* outFileSize)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, outFileSize, (int)(0));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, (ulong*)(default), (int)(0));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ReadOnlySpan<byte> mode, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, (ulong*)(default), paddingBytes);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, string mode, ulong* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(pStr0, pStr1, outFileSize, paddingBytes);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, string mode, ulong* outFileSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(pStr0, pStr1, outFileSize, (int)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, string mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(pStr0, pStr1, (ulong*)(default), (int)(0));
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, string mode, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (mode != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(mode);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(mode, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			void* ret = ImFileLoadToMemoryNative(pStr0, pStr1, (ulong*)(default), paddingBytes);
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, ReadOnlySpan<byte> mode, ulong* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, outFileSize, paddingBytes);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, ReadOnlySpan<byte> mode, ulong* outFileSize)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, outFileSize, (int)(0));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, ReadOnlySpan<byte> mode)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, (ulong*)(default), (int)(0));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, ReadOnlySpan<byte> mode, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				fixed (byte* pmode = mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, (ulong*)(default), paddingBytes);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, string mode, ulong* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, pStr0, outFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, string mode, ulong* outFileSize)
		{
			fixed (byte* pfilename = &filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, pStr0, outFileSize, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, string mode)
		{
			fixed (byte* pfilename = &filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, pStr0, (ulong*)(default), (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ref byte filename, string mode, int paddingBytes)
		{
			fixed (byte* pfilename = &filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, pStr0, (ulong*)(default), paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ref byte mode, ulong* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, outFileSize, paddingBytes);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ref byte mode, ulong* outFileSize)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, outFileSize, (int)(0));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ref byte mode)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, (ulong*)(default), (int)(0));
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, ref byte mode, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				fixed (byte* pmode = &mode)
				{
					void* ret = ImFileLoadToMemoryNative((byte*)pfilename, (byte*)pmode, (ulong*)(default), paddingBytes);
					return ret;
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, string mode, ulong* outFileSize, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, pStr0, outFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, string mode, ulong* outFileSize)
		{
			fixed (byte* pfilename = filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, pStr0, outFileSize, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, string mode)
		{
			fixed (byte* pfilename = filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, pStr0, (ulong*)(default), (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(ReadOnlySpan<byte> filename, string mode, int paddingBytes)
		{
			fixed (byte* pfilename = filename)
			{
				byte* pStr0 = null;
				int pStrSize0 = 0;
				if (mode != null)
				{
					pStrSize0 = Utils.GetByteCountUTF8(mode);
					if (pStrSize0 >= Utils.MaxStackallocSize)
					{
						pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
					}
					else
					{
						byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
						pStr0 = pStrStack0;
					}
					int pStrOffset0 = Utils.EncodeStringUTF8(mode, pStr0, pStrSize0);
					pStr0[pStrOffset0] = 0;
				}
				void* ret = ImFileLoadToMemoryNative((byte*)pfilename, pStr0, (ulong*)(default), paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, ref byte mode, ulong* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = &mode)
			{
				void* ret = ImFileLoadToMemoryNative(pStr0, (byte*)pmode, outFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, ref byte mode, ulong* outFileSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = &mode)
			{
				void* ret = ImFileLoadToMemoryNative(pStr0, (byte*)pmode, outFileSize, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, ref byte mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = &mode)
			{
				void* ret = ImFileLoadToMemoryNative(pStr0, (byte*)pmode, (ulong*)(default), (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, ref byte mode, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = &mode)
			{
				void* ret = ImFileLoadToMemoryNative(pStr0, (byte*)pmode, (ulong*)(default), paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, ReadOnlySpan<byte> mode, ulong* outFileSize, int paddingBytes)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = mode)
			{
				void* ret = ImFileLoadToMemoryNative(pStr0, (byte*)pmode, outFileSize, paddingBytes);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, ReadOnlySpan<byte> mode, ulong* outFileSize)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = mode)
			{
				void* ret = ImFileLoadToMemoryNative(pStr0, (byte*)pmode, outFileSize, (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		public static void* ImFileLoadToMemory(string filename, ReadOnlySpan<byte> mode)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (filename != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(filename);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(filename, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			fixed (byte* pmode = mode)
			{
				void* ret = ImFileLoadToMemoryNative(pStr0, (byte*)pmode, (ulong*)(default), (int)(0));
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					Utils.Free(pStr0);
				}
				return ret;
			}
		}
	}
}
